// Lab_05_2.cpp
// < Величко Іван >
// Лабораторна робота № 5.2
// Обчислення суми ряду Тейлора за допомогою функцій
// Варіант 0.4

#include <iostream>
#include <iomanip>
#include <cmath>

using namespace std;

// Прототипи функцій:
// L - обчислює суму ряду Тейлора для значення x з точністю eps
// A - обчислює наступний член ряду
void L(const double x, const double eps, int& n, double& s);
void A(const double x, const int n, double& a);

int main()
{
    // Оголошення змінних
    double xp, xk, x, dx, eps, a = 0, R = 0, s = 0;
    int n = 0;

    // Введення початкового (xp) і кінцевого (xk) значень x, кроку dx, та точності eps
    cout << "xp = "; cin >> xp;  // Вводимо початкове значення x
    cout << "xk = "; cin >> xk;  // Вводимо кінцеве значення x
    cout << "dx = "; cin >> dx;  // Вводимо крок зміни x
    cout << "eps = "; cin >> eps;  // Вводимо точність epsilon (eps)
    cout << fixed;  // Фіксуємо кількість знаків після коми для виведення результатів

    // Виведення заголовку таблиці для результатів
    cout << "-------------------------------------------------" << endl;
    cout << "|" << setw(7) << "x" << " |"      // Стовпець для значення x
        << setw(10) << "ln(x + 1)" << " |"      // Стовпець для точного значення ln(x + 1)
        << setw(10) << "S" << " |"            // Стовпець для суми ряду S
        << setw(5) << "n" << " |"            // Стовпець для кількості ітерацій n
        << endl;
    cout << "-------------------------------------------------" << endl;

    // Цикл по значеннях x від xp до xk з кроком dx
    x = xp;  // Початкове значення x

    // Цикл для обчислення суми ряду для кожного значення x
    while (x <= xk)
    {
        L(x, eps, n, s);  // Викликаємо функцію L для обчислення суми ряду з точністю eps

        // Виведення результатів у таблицю: x, точне значення ln(x + 1), наближене значення S, кількість ітерацій n
        cout << "|" << setw(7) << setprecision(2) << x << " |"  // Виводимо x з точністю до 2 знаків після коми
            << setw(10) << setprecision(5) << log(x + 1) << " |"  // Точне значення ln(x + 1)
            << setw(10) << setprecision(5) << s << " |"         // Наближене значення S
            << setw(5) << n << " |"                             // Кількість ітерацій
            << endl;
        x += dx;  // Збільшуємо x на крок dx
    }

    cout << "-------------------------------------------------" << endl;
    return 0;  // Завершення програми
}

// Функція L обчислює суму ряду для ln(x + 1) з точністю eps
// x - значення аргументу
// eps - точність обчислення
// n - кількість ітерацій, яка змінюється в процесі
// s - сума ряду
void L(const double x, const double eps, int& n, double& s)
{
    n = 0; // Початкова кількість ітерацій
    double a = x; // Початковий доданок ряду
    s = a;  // Початкова сума (перший член ряду)
    do {
        n++;  // Збільшуємо кількість ітерацій
        A(x, n, a);  // Обчислюємо наступний член ряду за допомогою функції A
        s += a;  // Додаємо його до суми
    } while (abs(a) >= eps);  // Продовжуємо, поки абсолютна величина доданка не стане меншою за eps
}

// Функція A обчислює наступний член ряду Тейлора
// x - значення аргументу
// n - номер ітерації
// a - поточний член ряду (оновлюється)
void A(const double x, const int n, double& a)
{
    double R = -x * n / (1.0 * n + 1);  // Обчислюємо співвідношення R для переходу до наступного члена ряду
    a *= R;  // Оновлюємо поточний член ряду за допомогою R
}
